在 PCA 和 ICA 中我们对信号，在时域上进行了相关性Covariance (协方差)和 Correlation Coefficient(相关系数)分析，同样的在频域上的相关性分析是什么呢？频域上的相关性分析叫做 Coherence (相干性) 分析。

本文先介绍 Coherence 的分析方法，再介绍如何通过多元回归模型构造数据。

### 1. 时域与频域相关性分析

在时域中 Correlation Coefficient ：
$$
r_{x y}=\frac{\sum_{t=1}^{N}(x(t)-\bar{x})(y(t)-\bar{y})}{\sqrt{\sum_{t=1}^{N}(x(t)-\bar{x})^{2} \sum_{t=1}^{N}(y(t)-\bar{y})^{2}}}
$$
在频域中 Coherence ：
$$
\operatorname{coh}_{x y}(f)=|\frac{\sum_{i=1}^{N}\left(X_{i}-\bar{X}\right)\left(Y_{i}-\bar{Y}\right)^{*}}{\sqrt{\sum_{i=1}^{N}\left(X_{i}-\bar{X}\right)\left(X_{i}-\bar{X}\right)^{*} \sum_{i=1}^{N}\left(Y_{i}-\bar{Y}\right)\left(Y_{i}-\bar{Y}\right)^{*}}}|
$$

### 2. 使用 MScohere 分析

 在 Matlab 中可以使用 MScohere() 函数对信号进行   Coherence 分析，同样的在python 中可以调用 scipy.signal 中可以调用 coherence() 函数。

> 在分析自相干的的时候是直接用 Welch Method 的，而coherence() 或者 MScohere() 与 Welch method 的调用方式非常相似。
>
> 注意： 与 welch method 一样，overlap 数据点的多少和窗口的长度(nfft) 的选择是非常重要的。

```python
# Matlab
[Sxx,F] = pwelch(X(i,:),hamming(nfft),noverlap,nfft,samplerate);
[Cxy,F] = mscohere(X(i,:),X(j,:),hamming(nfft),noverlap,nfft,samplerate);
# Python
[F,Sxx] = welch(X[i,:],samplerate,window,noverlap=noverlap,nfft=nfft)
[F,Cxy] = coherence(X[i,:],X[j,:],samplerate, window,noverlap=noverlap,nfft=nfft)

```

从下图可以看出大多数channel 在 0.1 Hz 有相干性（波峰），Channel 3 在0.1Hz 和 0.3 Hz 有两个波峰。

![mscoherence](C:\Users\Hongtao_Z\Downloads\mscoherence.png)

### 3. 多元回归(Multivalue Autoregressive)分析

#### 3.1 多元回归模型

类似于在时域中使用多项式拟合曲线的方法，在频域中可以使用多元回归的模型拟合频域信号，多元回归模型公式如下:
$$
{ \bf X } ( n ) = \sum _ { k = 1 } ^ { p } { \bf A } ( k ) { \bf X } ( n - k ) + { \bf U } ( n )
$$

> * p (maximum lag) 为模型的阶数 (类似于多项式的阶数)
> * A 为模型系数
> * U 为互不相干的高斯杂讯

#### 3.2 利用多元回归生成数据

刚刚分析的数据就是我们通过上面那个公式合成的，代码如下

```python
# Matlab
N=500;  % number of data points
M=4;    % number of variables
p=2; % maximum lag, the number of past points used for AR
r1=0.9; f1=0.1; % oscillation channel 1, f in Hz
r2=0; f2=0.1; % oscillation channel 2, f in Hz
r3=0.9; f3=0.3; % oscillation channel 3, f in Hz
r4=0; f4=0.1; % oscillation channel 4, f in Hz

%Residual covariance matrix (DIAGONAL)
Sw(1,:)=[1 0 0 0];
Sw(2,:)=[0 1 0 0];
Sw(3,:)=[0 0 1 0];
Sw(4,:)=[0 0 0 1];

%effects at lag 1
Bk(1,:,1)=[2*r1*cos(2*pi*f1) 0 0 0];
Bk(2,:,1)=[1 2*r2*cos(2*pi*f2) 0.5 0];
Bk(3,:,1)=[0 0.5 2*r3*cos(2*pi*f3) 0];
Bk(4,:,1)=[0 0 0 2*r4*cos(2*pi*f4)];
%effects at lag 2
Bk(1,:,2)=[-r1^2 0 0 0];
Bk(2,:,2)=[0 -r2^2 0 0];
Bk(3,:,2)=[0 0.5 -r3^2 0];
Bk(4,:,2)=[1 0 0 -r4^2];

% concateno in matrice Bm
A=[];
for kk=1:p
    A=[A Bk(:,:,kk)];
end

%% create simulated signal
U=randn(M,N); % uncorrelated gaussian innovations/noises
X=zeros(M,N);
for n=1:N
    for k=1:p
        if n-k<=0, break; end; % if n<=p, stop when k>=n
          X(:,n)=X(:,n) + ( Bk(:,:,k) * X(:,n-k) );
    end
     X(:,n)=X(:,n)+U(:,n);
end

# Python

## initialize parameters
N=500  # number of data points
M=4    # number of variables
p=2 # maximum lag, the number of past points used for AR
r1=0.9; f1=0.1 # oscillation channel 1, f in Hz
r2=0; f2=0.1 # oscillation channel 2, f in Hz
r3=0.9; f3=0.3 # oscillation channel 3, f in Hz
r4=0; f4=0.1 # oscillation channel 4, f in Hz

#Residual covariance matrix (DIAGONAL)
Sw = np.diag([1,1,1,1])

#effects at lag 1
Bk = np.zeros((4,4,2))

Bk[0,:,0]=[2*r1*cos(2*pi*f1), 0, 0, 0]
Bk[1,:,0]=[1, 2*r2*cos(2*pi*f2), 0.5, 0]
Bk[2,:,0]=[0, 0.5, 2*r3*cos(2*pi*f3), 0]
Bk[3,:,0]=[0, 0, 0, 2*r4*cos(2*pi*f4)]
#effects at lag 2
Bk[0,:,1]=[-r1**2, 0, 0, 0]
Bk[1,:,1]=[0, -r2**2, 0, 0]
Bk[2,:,1]=[0, 0.5, -r3**2, 0]
Bk[3,:,1]=[1, 0, 0, -r4**2]

# concateno in matrice Bm
A = np.hstack((Bk[:,:,0],Bk[:,:,1]))


```

从代码中看出，我们在第3个channel 中增加了 0.3Hz 的成分，所以自相干分析的时候可以看到两个波峰。